from github import Github
from github.InputGitTreeElement import InputGitTreeElement
from github.GithubException import BadCredentialsException, GithubException
import concurrent.futures


class connector_github:
    def __init__(self):
        # Guarantees that the user is authenticated
        self.authenticated_obj = None
        # Identifies the current user
        self.user_name = None
        # Identifies the current organization
        self.current_org = None
        # Useful for getting items related to the user organization (creating and acessing repos)
        self.org_session = None
        # Useful for getting items related to the user (creating and acessing repos)
        self.user_session = None
        # Identifies the current repo, allows to interact with it
        self.current_repo = None
        # Identifies the current branch, allows to interact with it
        self.current_branch = None

    # Debugger
    def current_env(self):
        print("Current environment/credentials:")

        print(f"Authenticated object: {self.authenticated_obj}")
        print(f"User name: {self.user_name}")
        print(f"Current organization: {self.current_org}")
        print(f"Organization session: {self.org_session}")
        print(f"User session: {self.user_session}")
        print(f"Current repo: {self.current_repo}")
        print(f"Current branch: {self.current_branch}")

        all_attributes = [self.authenticated_obj, self.user_name, self.current_org,
                          self.org_session, self.user_session, self.current_repo, self.current_branch]

        return all_attributes

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Authenticates the user with the given token

    def authenticate(self, token):
        print('Authenticating')

        try:
            # Initialize the GitHub client with the token
            client = Github(token)

            # Credentials check
            client.get_user().login

            # If the above call succeeds, authentication is successful
            print("Authentication successful!")

            # Reset the class attributes
            self.authenticated_obj = client
            self.user_session = client.get_user()
            self.user_name = client.get_user().login
            self.org_session = None
            self.current_org = None
            self.current_repo = None
            self.current_branch = None

            return True
        except BadCredentialsException:
            raise BadCredentialsException(
                "Bad credentials. Please check your token.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Resets credentials

    def close(self):
        """Close the connection by removing the authenticated session"""
        self.authenticated_obj = None
        self.user_name = None
        self.current_org = None
        self.org_session = None
        self.user_session = None
        self.current_repo = None
        self.current_branch = None
        print("GitHub connection closed")

        return None

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Gets the names of the organizations that the user has access to

    def get_all_orgs(self):
        """Gets names of the organizations that either the user access to."""

        if self.authenticated_obj:
            org_names = []
            # Checks if user is set and if there is an org
            orgs = self.user_session.get_orgs()

            # If there are orgs, returns the names
            if len(list(orgs)) > 0:
                for org in orgs:
                    org_names.append(org.login)
                print(f"Organizations found: {org_names}")
                return org_names

            else:
                print("No organizations found.")
                return orgs
        else:
            raise BadCredentialsException("Authenticate first.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Gets the names of the branches that exist for the current repository.

    def get_all_branches(self):
        """Gets names of the branches for the current repository."""

        if self.authenticated_obj:
            branch_names = []
            # Checks if user is set and if there is an org
            branches = self.current_repo.get_branches()

            # If there are orgs, returns the names
            if len(list(branches)) > 0:
                for branch in branches:
                    branch_names.append(branch.name)
                print(f"Branches found: {branch_names}")
                return branch_names

            else:
                print("No branches found.")
                return branch_names
        else:
            raise BadCredentialsException("Authenticate first.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Gets all repos for the current session

    def get_all_repos(self):
        """Gets names of the repositories that either the user or org has access to."""
        # Checks if org is set
        org = self.current_org

        if self.authenticated_obj:
            repos_list = []
            # Checks if user is set and if there is an org
            if org:
                print(f'Gathering all repositories that exist in {org}')
                for each in self.org_session.get_repos():
                    # print(each)
                    # print(repo_name)
                    repos_list.append(each.name)
                    print(f'Repository {each.name} found in {org}')
                return repos_list

            # Checks if user is set and if there is not an org
            elif not org:
                print(
                    f'Gathering all repositories that exist in {self.user_name}')
                for each in self.user_session.get_repos(type="owner"):
                    # print(each)
                    # print(repo_name)
                    repos_list.append(each.name)
                    print(
                        f'Repository {each.name} found in {self.user_name}')
                return repos_list

        else:
            raise BadCredentialsException("Authenticate first.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Check if repository exists

    def repository_exists(self, repo_name):
        # Checks if org is set
        org = self.current_org

        if self.authenticated_obj:
            # Checks if user is set and if there is an org
            if org:
                print(
                    f'Checking if repository {repo_name} exists in {org}')
                for each in self.org_session.get_repos():
                    # print(each)
                    # print(repo_name)
                    if each.name == repo_name:
                        print(f'Repository {repo_name} found in {org}')
                        return True
                print(f'Repository {repo_name} not found in {org}')
                return False

            # Checks if user is set and if there is not an org
            elif not org:
                print(f'Checking if repository {repo_name} exists')
                for each in self.user_session.get_repos(type="owner"):
                    # print(each)
                    # print(repo_name)
                    if each.name == repo_name:
                        print(f'Repository {repo_name} found')
                        return True
                print(f'Repository {repo_name} not found')
                return False

        else:
            raise BadCredentialsException("Authenticate first.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Create a new repository

    def create_repository(self, repo_name, description=None, private=False):
        print(f'Creating repository {repo_name}')
        """
        Create a repository.

        Args:
            repo_name (str): Name of the new repository.
            description (str): Description of the repository.
            private (bool): Whether the repository should be private.

        Returns:
            Repository: The created repository object or None if failed.
        """
        # Checks if org is set
        org = self.current_org

        if self.authenticated_obj:
            # Create it within the current organization
            if org:
                if not self.repository_exists(repo_name):
                    try:
                        self.org_session.create_repo(
                            name=repo_name,
                            description=description,
                            private=private
                        )
                        print(
                            f"Repository '{repo_name}' created successfully "
                            f"in organization '{org}'.")

                        chosen_repo = self.authenticated_obj.get_repo(
                            f"{org}/{repo_name}")

                        # Change the current repo to the one created
                        self.current_repo = chosen_repo
                        self.current_branch = chosen_repo.default_branch  # Should be main

                        # Must upload something in order to use the main branch after
                        file_path = "README.md"
                        readme_content = "Sample"
                        commit_message = "Initialize branches"

                        # Create the file in the repository
                        self.current_repo.create_file(
                            file_path, commit_message, readme_content)

                        print(self.current_repo)
                        return None

                    except GithubException:
                        raise GithubException(
                            f"Failed to create repository '{repo_name}' in org {org}: ")
                else:
                    # Change to the repo if it exists
                    self.switch_to_repo(repo_name)
                    print(
                        f"Repository '{repo_name}' already exists. Changed the current repo to it.")
                    warning_message = f"Repository '{repo_name}' already exists." \
                        "Changed the current repo to it."
                    return warning_message

            elif not org:
                if not self.repository_exists(repo_name):
                    try:
                        self.user_session.create_repo(
                            name=repo_name,
                            description=description,
                            private=private
                        )
                        print(
                            f"Repository '{repo_name}' created successfully "
                            f"in user '{self.user_name}'.")

                        chosen_repo = self.authenticated_obj.get_repo(
                            f"{self.user_name}/{repo_name}")

                        # Change the current repo to the one created
                        self.current_repo = chosen_repo
                        self.current_branch = chosen_repo.default_branch  # Should be main

                        # Must upload something in order to use the main branch after
                        file_path = "README.md"
                        readme_content = "Sample"
                        commit_message = "Initialize branches"

                        # Create the file in the repository
                        self.current_repo.create_file(
                            file_path, commit_message, readme_content)

                        return None

                    except GithubException:
                        raise GithubException(
                            f"Failed to create repository '{repo_name}' in org {org}: ")
                else:
                    # Change to the repo if it exists
                    self.switch_to_repo(repo_name)
                    print(
                        f"Repository '{repo_name}' already exists. Changed the current repo to it.")
                    warning_message = f"Repository '{repo_name}' already exists." \
                        "Changed the current repo to it."
                    return warning_message
        else:
            raise BadCredentialsException("Authenticate first.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Switches organization

    def switch_to_organization(self, org_name='user'):
        if self.authenticated_obj:
            # Go back to the user setting
            if org_name == 'user':
                self.org_session = None
                self.current_org = None
                message = f'Switching back to user {self.user_name}'
                print(message)
                return message
            else:
                orgs = self.get_all_orgs()
                for org in orgs:
                    if org == org_name:
                        print(f'Switching to organization {org_name}')
                        self.org_session = self.authenticated_obj.get_organization(
                            org_name)
                        self.current_org = org_name

                        return None
                return None
        else:
            raise BadCredentialsException("Authenticate first.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Get repository

    def switch_to_repo(self, repo_name):
        print(f'Retrieving repository {repo_name}')
        """
        Fetch a repository by its name using the authenticated Github instance.

        Args:
            repo_name (str): Name of the repository.

        Returns:
            Repository: Repository object if found, None if not.
        """
        # Checks if org is set
        org = self.current_org

        if self.authenticated_obj:
            if org:
                try:
                    if self.repository_exists(repo_name):
                        chosen_repo = self.authenticated_obj.get_repo(
                            f"{org}/{repo_name}"
                        )
                        self.current_repo = chosen_repo
                        self.current_branch = chosen_repo.default_branch  # Should be main
                        print(
                            f"Repository {self.current_repo.name} in organization {org} is ready")
                        return None

                except GithubException as e:
                    print(
                        f"Error retrieving repository '{repo_name}' in organization {org}: {e}")
                    return None

            elif not org:
                try:
                    if self.repository_exists(repo_name):
                        chosen_repo = self.authenticated_obj.get_repo(
                            f"{self.user_name}/{repo_name}"
                        )
                        self.current_repo = chosen_repo
                        self.current_branch = chosen_repo.default_branch  # Should be main
                        print(
                            f"Repository {self.current_repo.name} in user is ready")
                        return None

                except GithubException as e:
                    print(
                        f"Error retrieving repository '{repo_name}': {e}")
                    return None

        else:
            raise BadCredentialsException("Authenticate first.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Switches branches

    def switch_to_branch(self, branch_name):
        print(f'Switching to branch {branch_name}')
        if self.authenticated_obj:
            # Check out the branch
            branches = self.get_all_branches()
            for branch in branches:
                if branch == branch_name:
                    self.current_branch = branch_name
                    print(f"Switched to branch: {branch_name}")
                    return None
            return None
        else:
            raise BadCredentialsException("Authenticate first.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Removes all files in a branch

    def clear_branch(self):
        print(f'Clearing branch {self.current_branch}')
        """Deletes all files in the specified branch."""
        if self.authenticated_obj:
            try:
                # Get the branch reference (replace with the branch you want to commit to)
                branch = self.current_repo.get_branch(self.current_branch)

                branch_ref = self.current_repo.get_git_ref(
                    f"heads/{self.current_branch}")

                # Create a tree with a single empty file
                element = InputGitTreeElement(
                    path="placeholder.txt",
                    mode="100644",  # From the codebase context showing correct file mode
                    type="blob",
                    content=""
                )

                # Create new tree with just the placeholder
                new_tree = self.current_repo.create_git_tree([element])

                # Create commit with minimal tree
                parent_commit = self.current_repo.get_git_commit(
                    branch.commit.sha)
                new_commit = self.current_repo.create_git_commit(
                    "Remove all files", new_tree, [parent_commit])

                # Update branch reference
                branch_ref.edit(new_commit.sha)

                content = self.current_repo.get_contents(
                    "", ref=self.current_branch)  # Get all files

                for file in content:

                    self.current_repo.delete_file(
                        file.path,
                        f"Remove {file.path}",
                        file.sha,
                        branch=self.current_branch
                    )
                    # Get the current commit SHA after creating the placeholder
            except Exception as e:
                print(f"Error clearing branch: {e}")
                return None
        else:
            raise BadCredentialsException("Authenticate first.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Create a branch from the main branch

    def create_branches_from_main(self, branch_name):
        print(f'Creating branch {branch_name}')
        """
        Create branches from the main branch in the repository.
        """
        if self.authenticated_obj:
            try:
                # Create branch from main
                main_branch = self.current_repo.get_branch(
                    self.current_repo.default_branch)
                self.current_repo.create_git_ref(
                    f"refs/heads/{branch_name}", main_branch.commit.sha)
                print(f"Branch '{branch_name}' created successfully.")

                # Change to the new branch
                self.switch_to_branch(branch_name)
                return None

            except GithubException:
                raise GithubException(
                    f"Error creating branch '{branch_name}'.")
        else:
            raise BadCredentialsException("Authenticate first.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Creates a pull request

    def create_pull_request(self, base_branch, head_branch, title, body):
        print(
            f'Creating pull request from {head_branch} to {base_branch}')
        """
        Create a pull request on GitHub.

        Args:
            base_branch (str): The branch you want to merge into (e.g., "main").
            head_branch (str): The branch from which you want to create the pull request.
            title (str): The title of the pull request.
            body (str): The description of the pull request.

        Returns:
            PullRequest object: The created pull request.
        """
        if self.authenticated_obj:
            try:
                # Create the pull request
                pr = self.current_repo.create_pull(
                    title=title,
                    body=body,
                    base=base_branch,
                    head=head_branch
                )
                print(
                    f"Pull Request '{pr.title}' created successfully!")
                return None

            except GithubException:
                # 422: Unprocessable Entity (e.g.,  missing branch, no changes)
                print(GithubException.status)
                if GithubException.status == 422:
                    raise GithubException(
                        "⚠️ Error: Head branch doesn't exist or has no changes.")
                else:
                    raise GithubException("Error creating pull request.")

        else:
            raise BadCredentialsException("Authenticate first.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Gets all files in a repository

    def get_all_files(self):
        """Gets all file paths and content from the current repository, including files in subdirectories."""
        if not self.authenticated_obj:
            raise BadCredentialsException("Authenticate first.")

        # Get the latest commit hash from the current branch
        commit = self.current_repo.get_commits(sha=self.current_branch)[
            0]  # Get the latest commit

        # Get the tree of the latest commit (this will include all files in that commit)
        tree = self.current_repo.get_git_tree(sha=commit.sha, recursive=True)

        # Function to fetch file contents

        def fetch_file_contents(file_path):
            file = self.current_repo.get_contents(file_path)
            return file.path, file.decoded_content.decode()

        # List to store file info (path and content)
        all_files = []

        # Parallelize fetching files using concurrent.futures
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = []

            # Submit tasks to fetch file contents
            for item in tree.tree:
                if item.type == 'blob':  # 'blob' means it's a file, not a directory
                    futures.append(executor.submit(
                        fetch_file_contents, item.path))

            # Collect the results and populate the dictionary
            # Note: The sha will be usefull for uploading files later
            for future in concurrent.futures.as_completed(futures):
                file_path, file_content = future.result()
                all_files.append({"path": file_path, "content": file_content})

        # Print debugging info about the found files
        # print(
        #    f"Found {len(all_files)} files: {[file['path'] for file in all_files]}")
        return all_files

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Essentialy commit and push for a upload - for the current branch

    def upload_file(self, existing_files, files_to_upload):
        print(
            f"Uploading selected files to repository {self.current_repo.name}...")
        """
        Upload or update a single file in the repository.

        Args:
            file_path (str): Path of the file to upload.
            content (str): Content of the file to upload.
            commit_message (str): Commit message for the file.

        Returns:
            None
        """
        if self.authenticated_obj:
            existing_files_dict = {file['path']                                   : file for file in existing_files}
            print(existing_files_dict)

            try:
                # Create tree elements for all files to upload
                tree_elements = []
                print("Creating tree elements...")
                for item in files_to_upload:

                    mode = "100644"  # Regular file mode
                    path = item.get("path")
                    content = item.get("content")

                    print(path)
                    print(content)

                    element = InputGitTreeElement(
                        path=path,
                        mode=mode,
                        type="blob",
                        content=content
                    )
                    print(element)
                    tree_elements.append(element)

                print("Tree elements created.")

                # Try to get base tree if branch not empty
                try:
                    print("Getting base tree... (Branch not empty)")
                    base_tree = self.current_repo.get_git_tree(
                        self.current_repo.get_branch(self.current_branch).commit.sha)
                    new_tree = self.current_repo.create_git_tree(
                        tree_elements, base_tree)
                except:
                    print("Branch empty, creating new tree...")
                    new_tree = self.current_repo.create_git_tree(tree_elements)

                print("Creating the commit...")
                # Create a commit with the new tree
                parent_commit = self.current_repo.get_git_commit(
                    self.current_repo.get_branch(self.current_branch).commit.sha)
                new_commit = self.current_repo.create_git_commit(
                    "Update/Create multiple files", new_tree, [parent_commit])

                print("Commit created.")
                print("Pushing commit...")
                # Update branch reference
                branch_ref = self.current_repo.get_git_ref(
                    f"heads/{self.current_branch}")
                branch_ref.edit(new_commit.sha)
                print("Commit pushed.")

            except Exception as e:
                raise GithubException(
                    f"Error uploading file: {e}")

            # Trying to trigger this only when needed
            # Might be better to create a new class
            # attribute to indicate it the branch
            # still has the README.md or not
            if len(existing_files_dict) == 1:
                # Making sure README.md is not there anymore
                # as it as served its purpose
                try:
                    file_path = "README.md"
                    # Fetch the file from the current branch
                    file = self.current_repo.get_contents(
                        file_path,
                        ref=self.current_branch)

                    # Get the file's SHA (this is needed for deletion)
                    file_sha = file.sha

                    # Now delete the file
                    commit_message = f"Deleted {file_path}"
                    self.current_repo.delete_file(file_path, commit_message,
                                                  sha=file_sha, branch=self.current_branch)
                    print(
                        f"File '{file_path}' has been deleted \n"
                        f"from branch '{self.current_branch}'.")

                except GithubException as e:
                    if "Not Found" in str(e):
                        print(
                            f"The file '{file_path}' was not found \n"
                            f"in the branch '{self.current_branch}'.")
                    else:
                        print(f"An error occurred: {str(e)}")

        else:
            raise BadCredentialsException("Authenticate first.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################

    # Copy files from one repository to another

    def copy_files_to_repo(self, target_repo, description=None, private=False):
        print(
            f"Copying files from '{self.current_repo}' in the branch {self.current_branch} to '{target_repo}'.")
        """
        Copy all files from the source repository to the target repository.

        Args:
            source_repo (Repository): The source GitHub repository object.
            target_repo (Repository): The target GitHub repository object.

        Returns:
            None
        """
        if self.authenticated_obj:
            original_repo = self.current_repo
            # Ensure that there is no repo overwrite
            if not self.repository_exists(target_repo):

                # Gather all files from the source repository
                all_files = self.get_all_files()

                print(
                    f"Copying {len(all_files)} files from "
                    f"'{self.current_repo}' "
                    f"to '{target_repo}'."
                )

                # Create new repository, changes the current repo to it
                self.create_repository(
                    target_repo, description, private)

                # Add the files to the new repository
                print(
                    f"Creating files in the repo {self.current_repo}")
                print(f'In the branch {self.current_branch}')
                for file in all_files:
                    print(file)
                    try:
                        self.upload_file(file['path'], file['content'])
                        self.current_repo.create_file(file['path'], f"Copy {file['path']} from "
                                                      f"{original_repo}",
                                                      file['content'], branch=self.current_branch)
                        print(f"Copied '{file}' successfully.")

                    except GithubException:
                        raise GithubException(
                            f"Error creating file '{file['path']}'")

                return None
            else:
                raise GithubException(
                    f"Repository '{target_repo}' already exists.")
        else:
            raise BadCredentialsException("Authenticate first.")

    #################################################################################################################################
    #################################################################################################################################
    #################################################################################################################################
